Пакети, променливи и функции.
Научете oсновните съставни части на всяка програма на Go.

Авторите на Go
https://golang.org

* Пакети

Всяка програма на Go се състои от пакети.

Програмите започват изпълнението си в пакета `main`.

Тази програма използва пакетите с пътища за внасяне `"fmt"` и `"math/rand"`.

Общоприето е името на пакета да е последният елемент от пътя за внасяне.
Например пакетът `"math/rand"` съдържа файлове, започващи с твърдението `package`rand`.

*Забележка:* средата, в която се изпълняват програмите е предопределена
(детерминистична), така че винаги, когато изпълнявате примерната програма,
`rand.Intn` ще връща едно и също число.

(За да видите различно число, захранете числовия генератор; вижте [[https://golang.org/pkg/math/rand/#Seed][`rand.Seed`]].
(В игрището времето е непроменлива величина, така, че ще трябва да използвате нещо друго за захранване.)

.play basics/packages.go

* Внасяне (Imports)

Тази програма събира внасянията в едно като огражда пътищата в скоби.

Можете да пишете също отделни твърдения за внасяне, ето така:

	import "fmt"
	import "math"

Но по-добре е да се използва едно твърдение със скоби.

.play basics/imports.go

* Изнесени (exported) имена

В Go дадено наименование е „изнесено“, когато започва с главна буква.
`Pizza` например е изнесено, както и `Pi`, което е изнесено от пакета `math`.

`pizza` и `pi` не започват с главна буква – не са изнесени.

Когато внасяме пакет, имаме достъп само до изнесените имена от него.
Всяко „неизнесено“ име е недостъпно извън пакета.

Изпълнете кода. Обърнете внимание на съобщението за грешка.

За да оправите грешката, преименувайте `math.pi` на `math.Pi` и опитайте отново.

.play basics/exported-names.go

* Функции

Една функция може да приема нула или повече аргументи.

В този пример `add` приема два параметъра от тип `int`.

Забележете, че типът се намира след името на променливата.

(За да научите повече защо типовете са там, вижте [[https://blog.golang.org/gos-declaration-syntax][ тази статия за синтаксиса при обявяване на променливи в Go]].)

.play basics/functions.go

* Функции (продължение)

Когато два или повече последователни параметъра са от един и същи тип, достатъчно е да укажете типа
само веднъж след последния параметър.

В този пример съкратихме

	x int, y int

на

	x, y int

.play basics/functions-continued.go

* Връщане на повече стойности

Функциите могат да върнат повече от една стойност.

Функцията `swap` връща два низа.

.play basics/multiple-results.go

* Именувани стойности за връщане

Стойностите за връщане в Go могат да се именуват. В този случай променливите, които ще се връщат се смятат за обявени в началото на функцията.

Имената се използват за документиране значението на връщаните стойности.

Твърдението `return` без аргументи връща именуваните стойности за връщане. Този израз е познат като „голо“ връщане.

Голо връщане е добре да се ползва само в кратки функции, какъвто е примерът тук. Ако функцията е по-дълга, голото връщане затруднява четенето на изходния код.

.play basics/named-results.go

* Променливи

Твърдението `var` обявява списък с променливи. Както при списъка с аргументите на функции, типът се задава в края на твърдението.

Твърдението `var` може да се използва във функции и пакети. Виждаме и двата случая в този пример.

.play basics/variables.go

* Променливи с присвояване на стойности

Когато обявяваме променлива можем и да ѝ присвояваме стойност.

Ако присвояваме стойност, можем да не указваме типа. Променливата ще приеме типа на присвояваната стойност.

.play basics/variables-with-initializers.go

* Кратко обявяване на променливи

Краткото твърдение за присвояване `:=` може да се използва във функции вместо `var`.

Извън функция всяко твърдение започва с ключова дума (`var`, `func` и т.н.). Твърдението `:=` не може да се ползва извън функции.

.play basics/short-variable-declarations.go

* Основни типове

Основните (простите) типове в Go са

	bool

	string

	int  int8  int16  int32  int64
	uint uint8 uint16 uint32 uint64 uintptr

	byte // alias for uint8

	rune // alias for int32
	     // represents a Unicode code point

	float32 float64

	complex64 complex128

Примерът показва няколко типа променливи както и възможността
да се обединяват обявявания на променливи в блокове както е при твърденията за внасяне.

Типовете `int`, `uint`, and `uintptr` са ибикновенно 32-битови на 32-битови системи и 64-битови на 64-битови.
Когато ви трябва целочислена стойност, използвайте `int`,
освен ако нямате някаква особена причина да ползвате някакъв оразмерен тип
(int8  int16  int32  int64) или тип без знак (uint).

.play basics/basic-types.go

* Нулеви стойности

Обявените променливи без изрично присвоена стойност имат _нулева стойност_.

Нулевата стойност е:

- `0` за числови типове;
- `false` за булевия тип;
- `""` (празен низ) за низове.

.play basics/zero.go

* Превръщане на типове

Изразът `T(v)` превръща стойността `v` в типа `T`.

Някои числови превръщания:

	var i int = 42
	var f float64 = float64(i)
	var u uint = uint(f)

Или по-простичко:

	i := 42
	f := float64(i)
	u := uint(f)

За разлика от C, в Go присвояването на стойности от една променлива на друга с различен тип изисква изрично превръщане.
Опитайте да премахнете `float64` или `uint` превръщанията и вижте какво се случва.

.play basics/type-conversions.go

* Подразбиращи се типове

Когато обявявате променлива без да указвате изрично типа (като използвате правописа `:=` или `var`=` ), типът на променливата се подразбира от стойността от дясната страна на оператора за присвояване.

Когато стойността от дясната страна вече има тип, новата променлива приема същия тип:

	var i int
	j := i // j is an int

В случай обаче, че стойността от дясната страна представлява някаква числова непроменлива стойност, 
тогава променливата приема някой от типовете `int`, `float64`, или `complex128`
в зависимост от точността на константата:

	i := 42           // int
	f := 3.142        // float64
	g := 0.867 + 0.5i // complex128

Променете началната стойност на `v` в примерния код и вижте как се променя типа ѝ.

.play basics/type-inference.go

* Непроменливи (константи)

Непроменливите се обявяват като променливи, но се използва ключовата дума `const`.

Непроменливите могат да приемат знакови, низови, булеви или числови стойности.

Непроменливите не могат да бъдат обявявани с оператора `:=`.

.play basics/constants.go

* Числови непроменливи

Числовите непроменливи имат _стойности_ с висока точност.

Непроменливата без тип приема типа, наложен от контекста.

Опитайте също да покажете на екрана `needInt(Big)`.

(`int` може да съдържа най-много 64-битово цяло число, а понякога и по-малко.)

.play basics/numeric-constants.go

* Поздравления!

Завършихте този урок!

Можете да отидете обратно в списъка с [[/list][разделите]] и да изберете какво да научите, или да продължите със [[javascript:click('.next-page')][следващия урок]].
