Методи и интерфейси
В този урок научаваме за методите и интерфейсите, начините, чрез които създаваме обекти и задаваме тяхното поведение.

The Go Authors
https://golang.org

* Методи

Go няма класове.
Въпреки това можете да задавате методи на типовете.

Методът е функция с допълнителен аргумент, наречен _получател_.

Получателят се пише в отделен списък с аргументи между ключовата дума `func` и името на метода.

В този пример методът  `Abs` има получател от тип `Vertex`, именуван `v`.

.play methods/methods.go

* Методите са функции

Запомнете: методът е просто функция с допълнителен аргумент за получател.

Тук `Abs` е написана като обикновена функция със същото действие.

.play methods/methods-funcs.go

* Методи (продължение)

Можете да обявявате методи за типове, които не са структури.

В този пример виждаме числов тип `MyFloat` с метод `Abs`.

Можете да обявявате метод с получател, които се намира в същия пакет, в който е метода.
Не можете да обявявате метод с получател, обявен в друг пакет.
Това включва вградените в езика типове като `int`.

.play methods/methods-continued.go

* Получатели указатели

Можете да обявявате методи, които получават указатели.

Това означава, че получателят се изписва с тип `*T` за типа `T`.
(Също така, самият `T` не може да бъде указател, например `*int`.)

Например методът `Scale` е обявен за `*Vertex`.

Методите с получатели указатели могат да променят стойността,
към която указателят сочи (какъвто е случаят със `Scale` тук).
Тъй като често се налага методите да променят състоянието на получателя си,
по-често се срещат методи с получатели указатели, отколкото получатели стойности.

Махнете `*` от обявлението на функцията `Scale` на ред 16
и вижте как се променя поведението на програмата.

Когато получателят е стойност, методът `Scale` извършва действието си върху копие на стойноста от тип `Vertex`.
(Поведението е същото като при всеки друг аргумент на функцията.)
Методът `Scale` трябва да има получател указател (да получи указател),
за да промени стойността на `Vertex`, която бе обявена във функцията `main`.

.play methods/methods-pointers.go

* Указатели и функции

Тук виждаме методите `Abs` и `Scale` пренаписани като функции.

Отново махнете `*` от ред 16.
Разбирате ли защо се променя поведението?
Какво друго трябва да се промени за да се компилира примерът?

(Ако не сте сигурни, отидете на следващата страница.)

.play methods/methods-pointers-explained.go

* Методи и опосредстване на указателите

Като сравнявате предишните два примера трябва да сте забелязали, че на
функциите, обявени като приемащи аргумент указател, трябва да се подава
указател,

	var v Vertex
	ScaleFunc(v, 5)  // Грешка по време на компилиране!
	ScaleFunc(&v, 5) // Работи

докато методите с получатели указатели, могат да се извикват върху указател или стойност.

	var v Vertex
	v.Scale(5)  // Работи
	p := &v
	p.Scale(10) // Работи

При твърдението `v.Scale(5)`, въпреки че `v` е стойност, а не указател,
методът с получател указател се извиква автоматично.
За удобство Go превръща извикването `v.Scale(5)` във
`(&v).Scale(5)`, тъй като методът `Scale` има получател указател.

.play methods/indirection.go

* Методи и опосредстване на указателите (2)

Същото се случва и в обратната посока.

На функции, които приемат аргумент стойност, трябва да се подават само стойности от дадения тип,

	var v Vertex
	fmt.Println(AbsFunc(v))  // Работи
	fmt.Println(AbsFunc(&v)) // Грешка по време на компилиране!

докато методи със получатели стойности, могат да бъдат извиквани както върху стойност, така и върху указател.

	var v Vertex
	fmt.Println(v.Abs()) // Работи
	p := &v
	fmt.Println(p.Abs()) // Работи

В този случай извикването `p.Abs()` се превръща вътрешно в `(*p).Abs()`.

.play methods/indirection-values.go

* Как да изберем получател указател или стойност

Има две причини да изберете за получател указател.

Първата е, за да може методът да променя стойността, към която сочи указателят.

Втората е, за да избегнете копирането на стойността в паметта при всяко извикване на метода.
Това се оказва много удачно ако получателят е огромна структура.

В този случай и `Scale`, и `Abs` имат получатели указатели от тип `*Vertex`,
въпреки че методът `Abs` не променя стойността на получателя си.

По правило, всички методи на даден тип, трябва да получават само стойност или само указател.
Не смесвайте получателите на методите за един тип.
(Ще видим защо на следващите няколко страници)

.play methods/methods-with-pointer-receivers.go

* Интерфейси (взаимодействия)

Един _тип_интерфейс_ (_тип_взаимодействие_) се обявява като набор от описания на методи.

Типът взаимодействие може да съдържа всякаква стойност, която осъществява тези методи

*Забележка:* Има грешка в примерния код на ред 22.
`Vertex` (типът стойност) не осъществява (не имплементира) `Abser` защото
методът `Abs` е обявен само за `*Vertex` (указателя към типа).

.play methods/interfaces.go

* Интерфейсите се осъществяват без изрично указване

Даден тип осъществява интерфейс като осъществява неговите методи.
Няма изрично упоменаване на намеренията, няма ключова дума "implements".

Неявните интерфейси отделят описването на интерфейса от осъществяването му,
което може да се окаже в който и да е пакет без изрично указване.

.play methods/interfaces-are-satisfied-implicitly.go

* Interface values

Under the covers, interface values can be thought of as a tuple of a value and a
concrete type:

	(value, type)

An interface value holds a value of a specific underlying concrete type.

Calling a method on an interface value executes the method of the same name on
its underlying type.

.play methods/interface-values.go

* Interface values with nil underlying values

If the concrete value inside the interface itself is nil,
the method will be called with a nil receiver.

In some languages this would trigger a null pointer exception,
but in Go it is common to write methods that gracefully handle being called
with a nil receiver (as with the method `M` in this example.)

Note that an interface value that holds a nil concrete value is itself non-nil.

.play methods/interface-values-with-nil.go

* Nil interface values

A nil interface value holds neither value nor concrete type.

Calling a method on a nil interface is a run-time error because there is no
type inside the interface tuple to indicate which _concrete_ method to call.

.play methods/nil-interface-values.go

* The empty interface

The interface type that specifies zero methods is known as the _empty_interface_:

	interface{}

An empty interface may hold values of any type.
(Every type implements at least zero methods.)

Empty interfaces are used by code that handles values of unknown type.
For example, `fmt.Print` takes any number of arguments of type `interface{}`.

.play methods/empty-interface.go

* Type assertions

A _type_assertion_ provides access to an interface value's underlying concrete value.

	t := i.(T)

This statement asserts that the interface value `i` holds the concrete type `T`
and assigns the underlying `T` value to the variable `t`.

If `i` does not hold a `T`, the statement will trigger a panic.

To _test_ whether an interface value holds a specific type,
a type assertion can return two values: the underlying value
and a boolean value that reports whether the assertion succeeded.

	t, ok := i.(T)

If `i` holds a `T`, then `t` will be the underlying value and `ok` will be true.

If not, `ok` will be false and `t` will be the zero value of type `T`,
and no panic occurs.

Note the similarity between this syntax and that of reading from a map.

.play methods/type-assertions.go

* Type switches

A _type_switch_ is a construct that permits several type assertions in series.

A type switch is like a regular switch statement, but the cases in a type
switch specify types (not values), and those values are compared against
the type of the value held by the given interface value.

	switch v := i.(type) {
	case T:
		// here v has type T
	case S:
		// here v has type S
	default:
		// no match; here v has the same type as i
	}

The declaration in a type switch has the same syntax as a type assertion `i.(T)`,
but the specific type `T` is replaced with the keyword `type`.

This switch statement tests whether the interface value `i`
holds a value of type `T` or `S`.
In each of the `T` and `S` cases, the variable `v` will be of type
`T` or `S` respectively and hold the value held by `i`.
In the default case (where there is no match), the variable `v` is
of the same interface type and value as `i`.

.play methods/type-switches.go

* Stringers

One of the most ubiquitous interfaces is [[//golang.org/pkg/fmt/#Stringer][`Stringer`]] defined by the [[//golang.org/pkg/fmt/][`fmt`]] package.

	type Stringer interface {
		String() string
	}

A `Stringer` is a type that can describe itself as a string. The `fmt` package
(and many others) look for this interface to print values.

.play methods/stringer.go

* Exercise: Stringers

Make the `IPAddr` type implement `fmt.Stringer` to print the address as
a dotted quad.

For instance, `IPAddr{1,`2,`3,`4}` should print as `"1.2.3.4"`.

.play methods/exercise-stringer.go

* Errors

Go programs express error state with `error` values.

The `error` type is a built-in interface similar to `fmt.Stringer`:

	type error interface {
		Error() string
	}

(As with `fmt.Stringer`, the `fmt` package looks for the `error` interface when
printing values.)

Functions often return an `error` value, and calling code should handle errors
by testing whether the error equals `nil`.

	i, err := strconv.Atoi("42")
	if err != nil {
		fmt.Printf("couldn't convert number: %v\n", err)
		return
	}
	fmt.Println("Converted integer:", i)

A nil `error` denotes success; a non-nil `error` denotes failure.

.play methods/errors.go

* Exercise: Errors

Copy your `Sqrt` function from the [[/flowcontrol/8][earlier exercise]] and modify it to return an `error` value.

`Sqrt` should return a non-nil error value when given a negative number, as it doesn't support complex numbers.

Create a new type

	type ErrNegativeSqrt float64

and make it an `error` by giving it a

	func (e ErrNegativeSqrt) Error() string

method such that `ErrNegativeSqrt(-2).Error()` returns `"cannot`Sqrt`negative`number:`-2"`.

*Note:* a call to `fmt.Sprint(e)` inside the `Error` method will send the program into an infinite loop. You can avoid this by converting `e` first: `fmt.Sprint(float64(e))`. Why?

Change your `Sqrt` function to return an `ErrNegativeSqrt` value when given a negative number.

.play methods/exercise-errors.go

* Readers

The `io` package specifies the `io.Reader` interface,
which represents the read end of a stream of data.

The Go standard library contains [[https://golang.org/search?q=Read#Global][many implementations]] of these interfaces, including files, network connections, compressors, ciphers, and others.

The `io.Reader` interface has a `Read` method:

	func (T) Read(b []byte) (n int, err error)

`Read` populates the given byte slice with data and returns the number of bytes
populated and an error value. It returns an `io.EOF` error when the stream
ends.

The example code creates a
[[//golang.org/pkg/strings/#Reader][`strings.Reader`]]
and consumes its output 8 bytes at a time.

.play methods/reader.go

* Exercise: Readers

Implement a `Reader` type that emits an infinite stream of the ASCII character
`'A'`.

.play methods/exercise-reader.go

* Exercise: rot13Reader

A common pattern is an [[https://golang.org/pkg/io/#Reader][io.Reader]] that wraps another `io.Reader`, modifying the stream in some way.

For example, the [[https://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]] function takes an `io.Reader` (a stream of compressed data) and returns a `*gzip.Reader` that also implements `io.Reader` (a stream of the decompressed data).

Implement a `rot13Reader` that implements `io.Reader` and reads from an `io.Reader`, modifying the stream by applying the [[https://en.wikipedia.org/wiki/ROT13][rot13]] substitution cipher to all alphabetical characters.

The `rot13Reader` type is provided for you.
Make it an `io.Reader` by implementing its `Read` method.

.play methods/exercise-rot-reader.go

* Images

[[https://golang.org/pkg/image/#Image][Package image]] defines the `Image` interface:

	package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

*Note*: the `Rectangle` return value of the `Bounds` method is actually an
[[https://golang.org/pkg/image/#Rectangle][`image.Rectangle`]], as the
declaration is inside package `image`.

(See [[https://golang.org/pkg/image/#Image][the documentation]] for all the details.)

The `color.Color` and `color.Model` types are also interfaces, but we'll ignore that by using the predefined implementations `color.RGBA` and `color.RGBAModel`. These interfaces and types are specified by the [[https://golang.org/pkg/image/color/][image/color package]]

.play methods/images.go

* Exercise: Images

Remember the picture generator you wrote earlier? Let's write another one, but this time it will return an implementation of `image.Image` instead of a slice of data.

Define your own `Image` type, implement [[https://golang.org/pkg/image/#Image][the necessary methods]], and call `pic.ShowImage`.

`Bounds` should return a `image.Rectangle`, like `image.Rect(0,`0,`w,`h)`.

`ColorModel` should return `color.RGBAModel`.

`At` should return a color; the value `v` in the last picture generator corresponds to `color.RGBA{v,`v,`255,`255}` in this one.

.play methods/exercise-images.go

* Congratulations!

You finished this lesson!

You can go back to the list of [[/list][modules]] to find what to learn next, or continue with the [[javascript:click('.next-page')][next lesson]].
