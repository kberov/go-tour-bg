Методи и интерфейси
В този урок научаваме за методите и интерфейсите, начините, чрез които създаваме обекти и задаваме тяхното поведение.

The Go Authors
https://golang.org

* Методи

Go няма класове.
Въпреки това можете да задавате методи на типовете.

Методът е функция с допълнителен аргумент, наречен _получател_.

Получателят се пише в отделен списък с аргументи между ключовата дума `func` и името на метода.

В този пример методът  `Abs` има получател от тип `Vertex`, именуван `v`.

.play methods/methods.go

* Методите са функции

Запомнете: методът е просто функция с допълнителен аргумент за получател.

Тук `Abs` е написана като обикновена функция със същото действие.

.play methods/methods-funcs.go

* Методи (продължение)

Можете да обявявате методи за типове, които не са структури.

В този пример виждаме числов тип `MyFloat` с метод `Abs`.

Можете да обявявате метод с получател, които се намира в същия пакет, в който е метода.
Не можете да обявявате метод с получател, обявен в друг пакет.
Това включва вградените в езика типове като `int`.

.play methods/methods-continued.go

* Получатели указатели

Можете да обявявате методи, които получават указатели.

Това означава, че получателят се изписва с тип `*T` за типа `T`.
(Също така, самият `T` не може да бъде указател, например `*int`.)

Например методът `Scale` е обявен за `*Vertex`.

Методите с получатели указатели могат да променят стойността,
към която указателят сочи (какъвто е случаят със `Scale` тук).
Тъй като често се налага методите да променят състоянието на получателя си,
по-често се срещат методи с получатели указатели, отколкото получатели стойности.

Махнете `*` от обявлението на функцията `Scale` на ред 16
и вижте как се променя поведението на програмата.

Когато получателят е стойност, методът `Scale` извършва действието си върху копие на стойноста от тип `Vertex`.
(Поведението е същото като при всеки друг аргумент на функцията.)
Методът `Scale` трябва да има получател указател (да получи указател),
за да промени стойността на `Vertex`, която бе обявена във функцията `main`.

.play methods/methods-pointers.go

* Указатели и функции

Тук виждаме методите `Abs` и `Scale` пренаписани като функции.

Отново махнете `*` от ред 16.
Разбирате ли защо се променя поведението?
Какво друго трябва да се промени за да се компилира примерът?

(Ако не сте сигурни, отидете на следващата страница.)

.play methods/methods-pointers-explained.go

* Методи и опосредстване на указателите

Като сравнявате предишните два примера трябва да сте забелязали, че на
функциите, обявени като приемащи аргумент указател, трябва да се подава
указател,

	var v Vertex
	ScaleFunc(v, 5)  // Грешка по време на компилиране!
	ScaleFunc(&v, 5) // Работи

докато методите с получатели указатели, могат да се извикват върху указател или стойност.

	var v Vertex
	v.Scale(5)  // Работи
	p := &v
	p.Scale(10) // Работи

При твърдението `v.Scale(5)`, въпреки че `v` е стойност, а не указател,
методът с получател указател се извиква автоматично.
За удобство Go превръща извикването `v.Scale(5)` във
`(&v).Scale(5)`, тъй като методът `Scale` има получател указател.

.play methods/indirection.go

* Методи и опосредстване на указателите (2)

Същото се случва и в обратната посока.

На функции, които приемат аргумент стойност, трябва да се подават само стойности от дадения тип,

	var v Vertex
	fmt.Println(AbsFunc(v))  // Работи
	fmt.Println(AbsFunc(&v)) // Грешка по време на компилиране!

докато методи със получатели стойности, могат да бъдат извиквани както върху стойност, така и върху указател.

	var v Vertex
	fmt.Println(v.Abs()) // Работи
	p := &v
	fmt.Println(p.Abs()) // Работи

В този случай извикването `p.Abs()` се превръща вътрешно в `(*p).Abs()`.

.play methods/indirection-values.go

* Как да изберем получател указател или стойност

Има *две*причини* да изберете за получател указател.

Първата е, за да може методът да променя стойността, към която сочи указателят.

Втората е, за да избегнете копирането на стойността в паметта при всяко извикване на метода.
Това се оказва много удачно ако получателят е огромна структура.

В този случай и `Scale`, и `Abs` имат получатели указатели от тип `*Vertex`,
въпреки че методът `Abs` не променя стойността на получателя си.

По правило, всички методи на даден тип, трябва да получават само стойност или само указател.
Не смесвайте получателите на методите за един тип.
(Ще видим защо на следващите няколко страници)

.play methods/methods-with-pointer-receivers.go

* Взаимодействия (интерфейси)

_Тип_взаимодействие_ (_тип,_описващ_взаимодействие_с_други_типове_) се обявява като набор от описания на методи.

Типът взаимодействие може да съдържа всякаква стойност, която осъществява тези методи

*Забележка:* Има грешка в примерния код на ред 22.
`Vertex` (типът стойност) не осъществява (не имплементира) `Abser` защото
методът `Abs` е определен само за `*Vertex` (указателя към типа).

.play methods/interfaces.go

* Типовете взаимодействия се осъществяват без изрично указване

Даден тип осъществява тип взаимодействие (интерфейс) просто
чрез осъществяване на неговите методи.
Няма изрично упоменаване на намеренията, няма ключова дума "implements".

Неявните типове взаимодействия отделят описването на типа от осъществяването му,
което може да се окаже, в който и да е пакет, без допълнително указание.

.play methods/interfaces-are-satisfied-implicitly.go

* Стойности на типовете взаимодействия

Стойностите на типовете взаимодействия могат да бъдат разбирани като
двойка стойност и определен тип:

	(value, type)

Една стойност на тип взаимодействие съдържа стойност от определен отделен тип.

Като извикваме метод върху стойност на тип взаимодействие,
ние изпълняваме определен метод със същото име.
Този метод е обявен за стойности на отделния текущ тип.

.play methods/interface-values.go

* Стойности на типове взаимодействие, съдържащи `nil`

Ако дадена стойност на типа за взаимодействие е `nil`,
методът ще бъде изпълнен върху получател със стойност `nil`.

В някои езици това ще предизвика изключение при използване на нулев указател
(null pointer exception), но в Go често може да срещнете методи, които обработват случаите,
в които са извикани върху получатели със стойност `nil`.
(Такъв е случаят с метода `M` в този пример.)

Забележете, че стойност на тип взаимодействие, която съдържа нулева стойност, сама по себе си не е `nil`.

.play methods/interface-values-with-nil.go

* Стойности на типове за взаимодействие, които са `nil`.

`nil` стойности на типове за взаимодействие не съдържат нито стойност, нито определен тип.

Извикването на метод върху такава стойност предизвиква грешка по време на изпълнение,
защото няма тип в двойката „тип за взаимодействие - стойност",
който да осъществява извиквания метод.

.play methods/nil-interface-values.go

* Празният интерфейс (празен тип за взаимодействие)

Типът за взаимодействие, който не описва никакви методи, се нарича _празен_:

	interface{}

Празен тип за взаимодействие може да съдържа стойност от всякакъв тип.
(Всеки тип осъществява поне нула метода.)

Празен интерфейс се използва от програмен код, който обработва данни с непознат тип.
Например, `fmt.Print` приема неограничен брой аргументи от тип `interface{}`.

.play methods/empty-interface.go

* Потвърждения за типа с присвояване на стойност (type assertions)

_Потвърждаването_на_типа_ предоставя възможност за присвояване на стойността от действителния тип.

	t := i.(T)

Това твърдение потвърждава, че стойността на типа за взаимодействие `i` е от действителния тип `T`
и присвоява стойността с тип `T` на променливата `t`.

Ако `i` не е всъщност от тип `T`, твърдението ще хвърли грешка по време на изпълнение (panic).

За да _проверим_ какъв е действителния тип на дадена стойност,
трябва да присвоим стойности на две променливи - стойността,
която ще има действителния тип и булева стойност, която указва дали потвърждаването на типа е успешно.

	t, ok := i.(T)

Ако `i` е от тип `T`, то на `t` ще се присвои действителната стойност, а `ok` ще бъде истина (true).

Ако ли не, `ok` ще бъде лъжа (false), а `t` ще съдържа нулевата стойност за типа `T`.
В този случай няма да бъде хвърлена паническа грешка.

Забележете приликата на това изписване с четенето от речник/карта.

.play methods/type-assertions.go

* Switch с типове (type switch)

_Switch_с_типове_ е конструкция, която позволява няколко
проверки за потвърждаване на типа последователно.

Switch с типове е като обикновеното твърдение switch,
но в този случай се проверяват типове, а не стойности.
Последователно се проверява от какъв тип е стойността.

	switch v := i.(type) {
	case T:
		// тук v е от тип T
	case S:
		// тук v е от тип S
	default:
		// не е открито съвпадение; тук v има същия тип като i
	}

Обявяването на променливата се изписва както при обикновеното потвърждаване `i.(T)`,
но типа `T` се заменя с ключовата дума `type`.

Този израз switch проверява дали стойността `i` от текущия тип за взаимодействие
съдържа стойност от тип `T` или `S`. При всеки от случаите 
`T` и `S`, променливата `v` ще бъде проверена дали съдържа стойност от съответния действителен тип.
При подразбиращия се случаи (default case), когато няма съвпадение,
стойността е със същия взаимодействен тип като `i`.

.play methods/type-switches.go

* Stringers

Един от най-разпространените типове за взаимодействие [[//golang.org/pkg/fmt/#Stringer][`Stringer`]]
е описан в пакета [[//golang.org/pkg/fmt/][`fmt`]].

	type Stringer interface {
		String() string
	}

`Stringer` е тип, който може да представи себе си като низ. Пакетът `fmt` package
(и много други) търсят това взаимодействие, за да отпечатват стойности.

.play methods/stringer.go

* Упражнение: Stringers

Направете типа `IPAddr` да осъществява `fmt.Stringer`,
за да може да отпечатва адреса като четири числа с точки.

Например, `IPAddr{1,`2,`3,`4}` да се отпечатва като `"1.2.3.4"`.

.play methods/exercise-stringer.go

* Грешки

Go programs express error state with `error` values.

The `error` type is a built-in interface similar to `fmt.Stringer`:

	type error interface {
		Error() string
	}

(As with `fmt.Stringer`, the `fmt` package looks for the `error` interface when
printing values.)

Functions often return an `error` value, and calling code should handle errors
by testing whether the error equals `nil`.

	i, err := strconv.Atoi("42")
	if err != nil {
		fmt.Printf("couldn't convert number: %v\n", err)
		return
	}
	fmt.Println("Converted integer:", i)

A nil `error` denotes success; a non-nil `error` denotes failure.

.play methods/errors.go

* Exercise: Errors

Copy your `Sqrt` function from the [[/flowcontrol/8][earlier exercise]] and modify it to return an `error` value.

`Sqrt` should return a non-nil error value when given a negative number, as it doesn't support complex numbers.

Create a new type

	type ErrNegativeSqrt float64

and make it an `error` by giving it a

	func (e ErrNegativeSqrt) Error() string

method such that `ErrNegativeSqrt(-2).Error()` returns `"cannot`Sqrt`negative`number:`-2"`.

*Note:* a call to `fmt.Sprint(e)` inside the `Error` method will send the program into an infinite loop. You can avoid this by converting `e` first: `fmt.Sprint(float64(e))`. Why?

Change your `Sqrt` function to return an `ErrNegativeSqrt` value when given a negative number.

.play methods/exercise-errors.go

* Readers

The `io` package specifies the `io.Reader` interface,
which represents the read end of a stream of data.

The Go standard library contains [[https://golang.org/search?q=Read#Global][many implementations]] of these interfaces, including files, network connections, compressors, ciphers, and others.

The `io.Reader` interface has a `Read` method:

	func (T) Read(b []byte) (n int, err error)

`Read` populates the given byte slice with data and returns the number of bytes
populated and an error value. It returns an `io.EOF` error when the stream
ends.

The example code creates a
[[//golang.org/pkg/strings/#Reader][`strings.Reader`]]
and consumes its output 8 bytes at a time.

.play methods/reader.go

* Exercise: Readers

Implement a `Reader` type that emits an infinite stream of the ASCII character
`'A'`.

.play methods/exercise-reader.go

* Exercise: rot13Reader

A common pattern is an [[https://golang.org/pkg/io/#Reader][io.Reader]] that wraps another `io.Reader`, modifying the stream in some way.

For example, the [[https://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]] function takes an `io.Reader` (a stream of compressed data) and returns a `*gzip.Reader` that also implements `io.Reader` (a stream of the decompressed data).

Implement a `rot13Reader` that implements `io.Reader` and reads from an `io.Reader`, modifying the stream by applying the [[https://en.wikipedia.org/wiki/ROT13][rot13]] substitution cipher to all alphabetical characters.

The `rot13Reader` type is provided for you.
Make it an `io.Reader` by implementing its `Read` method.

.play methods/exercise-rot-reader.go

* Images

[[https://golang.org/pkg/image/#Image][Package image]] defines the `Image` interface:

	package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

*Note*: the `Rectangle` return value of the `Bounds` method is actually an
[[https://golang.org/pkg/image/#Rectangle][`image.Rectangle`]], as the
declaration is inside package `image`.

(See [[https://golang.org/pkg/image/#Image][the documentation]] for all the details.)

The `color.Color` and `color.Model` types are also interfaces, but we'll ignore that by using the predefined implementations `color.RGBA` and `color.RGBAModel`. These interfaces and types are specified by the [[https://golang.org/pkg/image/color/][image/color package]]

.play methods/images.go

* Exercise: Images

Remember the picture generator you wrote earlier? Let's write another one, but this time it will return an implementation of `image.Image` instead of a slice of data.

Define your own `Image` type, implement [[https://golang.org/pkg/image/#Image][the necessary methods]], and call `pic.ShowImage`.

`Bounds` should return a `image.Rectangle`, like `image.Rect(0,`0,`w,`h)`.

`ColorModel` should return `color.RGBAModel`.

`At` should return a color; the value `v` in the last picture generator corresponds to `color.RGBA{v,`v,`255,`255}` in this one.

.play methods/exercise-images.go

* Congratulations!

You finished this lesson!

You can go back to the list of [[/list][modules]] to find what to learn next, or continue with the [[javascript:click('.next-page')][next lesson]].
