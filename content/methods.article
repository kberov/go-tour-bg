Методи и интерфейси
В този урок научаваме за методите и интерфейсите, начините, чрез които създаваме обекти и задаваме тяхното поведение.

The Go Authors
https://golang.org

* Методи

Go няма класове.
Въпреки това можете да задавате методи на типовете.

Методът е функция с допълнителен аргумент, наречен _получател_.

Получателят се пише в отделен списък с аргументи между ключовата дума `func` и името на метода.

В този пример методът  `Abs` има получател от тип `Vertex`, именуван `v`.

.play methods/methods.go

* Методите са функции

Запомнете: методът е просто функция с допълнителен аргумент за получател.

Тук `Abs` е написана като обикновена функция със същото действие.

.play methods/methods-funcs.go

* Методи (продължение)

Можете да обявявате методи за типове, които не са структури.

В този пример виждаме числов тип `MyFloat` с метод `Abs`.

Можете да обявявате метод с получател, които се намира в същия пакет, в който е метода.
Не можете да обявявате метод с получател, обявен в друг пакет.
Това включва вградените в езика типове като `int`.

.play methods/methods-continued.go

* Получатели указатели

Можете да обявявате методи, които получават указатели.

Това означава, че получателят се изписва с тип `*T` за типа `T`.
(Също така, самият `T` не може да бъде указател, например `*int`.)

Например методът `Scale` е обявен за `*Vertex`.

Методите с получатели указатели могат да променят стойността,
към която указателят сочи (какъвто е случаят със `Scale` тук).
Тъй като често се налага методите да променят състоянието на получателя си,
по-често се срещат методи с получатели указатели, отколкото получатели стойности.

Махнете `*` от обявлението на функцията `Scale` на ред 16
и вижте как се променя поведението на програмата.

Когато получателят е стойност, методът `Scale` извършва действието си върху копие на стойноста от тип `Vertex`.
(Поведението е същото като при всеки друг аргумент на функцията.)
Методът `Scale` трябва да има получател указател (да получи указател),
за да промени стойността на `Vertex`, която бе обявена във функцията `main`.

.play methods/methods-pointers.go

* Указатели и функции

Тук виждаме методите `Abs` и `Scale` пренаписани като функции.

Отново махнете `*` от ред 16.
Разбирате ли защо се променя поведението?
Какво друго трябва да се промени за да се компилира примерът?

(Ако не сте сигурни, отидете на следващата страница.)

.play methods/methods-pointers-explained.go

* Методи и опосредстване на указателите

Като сравнявате предишните два примера трябва да сте забелязали, че на
функциите, обявени като приемащи аргумент указател, трябва да се подава
указател,

	var v Vertex
	ScaleFunc(v, 5)  // Грешка по време на компилиране!
	ScaleFunc(&v, 5) // Работи

докато методите с получатели указатели, могат да се извикват върху указател или стойност.

	var v Vertex
	v.Scale(5)  // Работи
	p := &v
	p.Scale(10) // Работи

При твърдението `v.Scale(5)`, въпреки че `v` е стойност, а не указател,
методът с получател указател се извиква автоматично.
За удобство Go превръща извикването `v.Scale(5)` във
`(&v).Scale(5)`, тъй като методът `Scale` има получател указател.

.play methods/indirection.go

* Методи и опосредстване на указателите (2)

Същото се случва и в обратната посока.

На функции, които приемат аргумент стойност, трябва да се подават само стойности от дадения тип,

	var v Vertex
	fmt.Println(AbsFunc(v))  // Работи
	fmt.Println(AbsFunc(&v)) // Грешка по време на компилиране!

докато методи със получатели стойности, могат да бъдат извиквани както върху стойност, така и върху указател.

	var v Vertex
	fmt.Println(v.Abs()) // Работи
	p := &v
	fmt.Println(p.Abs()) // Работи

В този случай извикването `p.Abs()` се превръща вътрешно в `(*p).Abs()`.

.play methods/indirection-values.go

* Как да изберем получател указател или стойност

Има *две*причини* да изберете за получател указател.

Първата е, за да може методът да променя стойността, към която сочи указателят.

Втората е, за да избегнете копирането на стойността в паметта при всяко извикване на метода.
Това се оказва много удачно ако получателят е огромна структура.

В този случай и `Scale`, и `Abs` имат получатели указатели от тип `*Vertex`,
въпреки че методът `Abs` не променя стойността на получателя си.

По правило, всички методи на даден тип, трябва да получават само стойност или само указател.
Не смесвайте получателите на методите за един тип.
(Ще видим защо на следващите няколко страници)

.play methods/methods-with-pointer-receivers.go

* Взаимодействия (интерфейси)

_Тип_взаимодействие_ (_тип,_описващ_взаимодействие_с_други_типове_) се обявява като набор от описания на методи.

Типът взаимодействие може да съдържа всякаква стойност, която осъществява тези методи

*Забележка:* Има грешка в примерния код на ред 22.
`Vertex` (типът стойност) не осъществява (не имплементира) `Abser` защото
методът `Abs` е определен само за `*Vertex` (указателя към типа).

.play methods/interfaces.go

* Типовете взаимодействия се осъществяват без изрично указване

Даден тип осъществява тип взаимодействие (интерфейс) просто
чрез осъществяване на неговите методи.
Няма изрично упоменаване на намеренията, няма ключова дума "implements".

Неявните типове взаимодействия отделят описването на типа от осъществяването му,
което може да се окаже, в който и да е пакет, без допълнително указание.

.play methods/interfaces-are-satisfied-implicitly.go

* Стойности на типовете взаимодействия

Стойностите на типовете взаимодействия могат да бъдат разбирани като
двойка стойност и определен тип:

	(value, type)

Една стойност на тип взаимодействие съдържа стойност от определен отделен тип.

Като извикваме метод върху стойност на тип взаимодействие,
ние изпълняваме определен метод със същото име.
Този метод е обявен за стойности на отделния текущ тип.

.play methods/interface-values.go

* Стойности на типове взаимодействие, съдържащи `nil`

Ако дадена стойност на типа за взаимодействие е `nil`,
методът ще бъде изпълнен върху получател със стойност `nil`.

В някои езици това ще предизвика изключение при използване на нулев указател
(null pointer exception), но в Go често може да срещнете методи, които обработват случаите,
в които са извикани върху получатели със стойност `nil`.
(Такъв е случаят с метода `M` в този пример.)

Забележете, че стойност на тип взаимодействие, която съдържа нулева стойност, сама по себе си не е `nil`.

.play methods/interface-values-with-nil.go

* Стойности на типове за взаимодействие, които са `nil`.

`nil` стойности на типове за взаимодействие не съдържат нито стойност, нито определен тип.

Извикването на метод върху такава стойност предизвиква грешка по време на изпълнение,
защото няма тип в двойката „тип за взаимодействие - стойност",
който да осъществява извиквания метод.

.play methods/nil-interface-values.go

* Празният интерфейс (празен тип за взаимодействие)

Типът за взаимодействие, който не описва никакви методи, се нарича _празен_:

	interface{}

Празен тип за взаимодействие може да съдържа стойност от всякакъв тип.
(Всеки тип осъществява поне нула метода.)

Празен интерфейс се използва от програмен код, който обработва данни с непознат тип.
Например, `fmt.Print` приема неограничен брой аргументи от тип `interface{}`.

.play methods/empty-interface.go

* Потвърждения за типа с присвояване на стойност (type assertions)

_Потвърждаването_на_типа_ предоставя възможност за присвояване на стойността от действителния тип.

	t := i.(T)

Това твърдение потвърждава, че стойността на типа за взаимодействие `i` е от действителния тип `T`
и присвоява стойността с тип `T` на променливата `t`.

Ако `i` не е всъщност от тип `T`, твърдението ще хвърли грешка по време на изпълнение (panic).

За да _проверим_ какъв е действителния тип на дадена стойност,
трябва да присвоим стойности на две променливи - стойността,
която ще има действителния тип и булева стойност, която указва дали потвърждаването на типа е успешно.

	t, ok := i.(T)

Ако `i` е от тип `T`, то на `t` ще се присвои действителната стойност, а `ok` ще бъде истина (true).

Ако ли не, `ok` ще бъде лъжа (false), а `t` ще съдържа нулевата стойност за типа `T`.
В този случай няма да бъде хвърлена паническа грешка.

Забележете приликата на това изписване с четенето от речник/карта.

.play methods/type-assertions.go

* Switch с типове (type switch)

_Switch_с_типове_ е конструкция, която позволява няколко
проверки за потвърждаване на типа последователно.

Switch с типове е като обикновеното твърдение switch,
но в този случай се проверяват типове, а не стойности.
Последователно се проверява от какъв тип е стойността.

	switch v := i.(type) {
	case T:
		// тук v е от тип T
	case S:
		// тук v е от тип S
	default:
		// не е открито съвпадение; тук v има същия тип като i
	}

Обявяването на променливата се изписва както при обикновеното потвърждаване `i.(T)`,
но типа `T` се заменя с ключовата дума `type`.

Този израз switch проверява дали стойността `i` от текущия тип за взаимодействие
съдържа стойност от тип `T` или `S`. При всеки от случаите 
`T` и `S`, променливата `v` ще бъде проверена дали съдържа стойност от съответния действителен тип.
При подразбиращия се случаи (default case), когато няма съвпадение,
стойността е със същия взаимодействен тип като `i`.

.play methods/type-switches.go

* Stringers

Един от най-разпространените типове за взаимодействие [[//golang.org/pkg/fmt/#Stringer][`Stringer`]]
е описан в пакета [[//golang.org/pkg/fmt/][`fmt`]].

	type Stringer interface {
		String() string
	}

`Stringer` е тип, който може да представи себе си като низ. Пакетът `fmt` package
(и много други) търсят това взаимодействие, за да отпечатват стойности.

.play methods/stringer.go

* Упражнение: Stringers

Направете типа `IPAddr` да осъществява `fmt.Stringer`,
за да може да отпечатва адреса като четири числа с точки.

Например, `IPAddr{1,`2,`3,`4}` да се отпечатва като `"1.2.3.4"`.

.play methods/exercise-stringer.go

* Грешки

Програмите, написани на Go изразяват състояние за грешка чрез стойности `error`.

Типът `error` е стандартен тип за взаимодействие, подобен на `fmt.Stringer`:

	type error interface {
		Error() string
	}

(Както при `fmt.Stringer`, пакетът `fmt`  търси типа за взаимодействие `error`,
когато отпечатва стойности за грешка.)

Функциите често връщат стойности от тип `error` и извикващия код
трябва да ги обработва като проверява дали грешката не е `nil`.

	i, err := strconv.Atoi("42")
	if err != nil {
		fmt.Printf("превръщането в число е неуспешно: %v\n", err)
		return
	}
	fmt.Println("Превърнато в цяло число:", i)

Грешка със стойност  `nil` означава успех; `error`, която не е `nil` означава провал.

.play methods/errors.go

* Упражнение: Грешки

Копирайте функцията `Sqrt` от [[/flowcontrol/8][предишното упражнение]] и я променете така,
че да връща стойност от тип `error`.

`Sqrt` трябва да върне ненулева стойност за грешка при подаване на на отрицателно число,
тъй като не поддържа отрицателни числа.

Създайте нов тип

	type ErrNegativeSqrt float64

и го направете с взаимодействие `error` като му добавите метод

	func (e ErrNegativeSqrt) Error() string

който при използване `ErrNegativeSqrt(-2).Error()` връща `"cannot`Sqrt`negative`number:`-2"`.

*Забележка:* Когато извикате `fmt.Sprint(e)` в метода `Error`, програмта ще влезе в безкраен цикъл. Това може да се избегне като предварително превърнете `e` в друг тип: `fmt.Sprint(float64(e))`. Защо?

Променете функцията `Sqrt` така, че да връща стойност от тип `ErrNegativeSqrt`, когато ѝ се подаде отрицателно число.

.play methods/exercise-errors.go

* Четци (Readers)

Пакетът `io` описва типа за взаимодействие `io.Reader`,
който представлява края на четенето на поток от данни.

Стандартната библиотека на Go съдържа [[https://golang.org/search?q=Read#Global][много изпълнения]]
на тези типове за взаимодействия, включващи работа с файлове,
установяване на връзка с мрежи, архиватори, шифри и други.

Типът за взаимодействие `io.Reader` има метод `Read`:

	func (T) Read(b []byte) (n int, err error)

`Read` пълни подадения отрязък байтове с данни и връща броя на добавените байтове и стойност за грешка.
Когато потокът от данни свърши, грешката е `io.EOF`.

Примерният код създава
[[//golang.org/pkg/strings/#Reader][`strings.Reader`]]
и приема изхода от него на късове от 8 байта.

.play methods/reader.go

* Упражнение: Четци

Създайте тип `Reader`, който връща безкраен поток от ASCII знака `'A'`.

.play methods/exercise-reader.go

* Упражнение: rot13Reader

Често един [[https://golang.org/pkg/io/#Reader][io.Reader]]
обгръща друг `io.Reader`, като променя потока от знаци по някакъв начин.

Например функцията [[https://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]]
приема `io.Reader` (поток от архивирани данни) и връща `*gzip.Reader`,
който също осъществява `io.Reader` (поток от разархивирани данни).

Създайте `rot13Reader`, който осъществява `io.Reader` и чете от `io.Reader`,
като променя потока, прилагайки шифриращия алгоритъм
[[https://en.wikipedia.org/wiki/ROT13][rot13]] върху всички буквени знаци.

Типът `rot13Reader` се намира в кода вече.
Направете го да взаимодейства като `io.Reader` като напишете метода `Read`.

.play methods/exercise-rot-reader.go

* Изображения

[[https://golang.org/pkg/image/#Image][Пакетът image]] описва типа за взаимодействие `Image`:

	package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

*Забележка*: the `Rectangle` return value of the `Bounds` method is actually an
[[https://golang.org/pkg/image/#Rectangle][`image.Rectangle`]], as the
declaration is inside package `image`.

(See [[https://golang.org/pkg/image/#Image][the documentation]] for all the details.)

The `color.Color` and `color.Model` types are also interfaces, but we'll ignore that by using the predefined implementations `color.RGBA` and `color.RGBAModel`. These interfaces and types are specified by the [[https://golang.org/pkg/image/color/][image/color package]]

.play methods/images.go

* Exercise: Images

Remember the picture generator you wrote earlier? Let's write another one, but this time it will return an implementation of `image.Image` instead of a slice of data.

Define your own `Image` type, implement [[https://golang.org/pkg/image/#Image][the necessary methods]], and call `pic.ShowImage`.

`Bounds` should return a `image.Rectangle`, like `image.Rect(0,`0,`w,`h)`.

`ColorModel` should return `color.RGBAModel`.

`At` should return a color; the value `v` in the last picture generator corresponds to `color.RGBA{v,`v,`255,`255}` in this one.

.play methods/exercise-images.go

* Congratulations!

You finished this lesson!

You can go back to the list of [[/list][modules]] to find what to learn next, or continue with the [[javascript:click('.next-page')][next lesson]].
